#include "decoder_cache.hpp"

namespace riscv
{
	enum ICACHE_OPS {
		OP_ILLEGAL = 0,
		OP_UNIMPLEMENTED,
		OP_NOP,

		OP_LOAD_I8,
		OP_LOAD_I8_DUMMY,
		OP_LOAD_I16,
		OP_LOAD_I16_DUMMY,
		OP_LOAD_I32,
		OP_LOAD_I32_DUMMY,
		OP_LOAD_U8,
		OP_LOAD_U16,
		OP_LOAD_U32,
		OP_LOAD_U64,
		OP_LOAD_U64_DUMMY,

		OP_STORE_I8,
		OP_STORE_I8_IMM,
		OP_STORE_I16_IMM,
		OP_STORE_I32_IMM,
		OP_STORE_I64_IMM,

		OP_BRANCH_EQ,
		OP_BRANCH_NE,
		OP_BRANCH_LT,
		OP_BRANCH_GE,
		OP_BRANCH_LTU,
		OP_BRANCH_GEU,

		OP_JALR,
		OP_JAL,
		OP_OP_IMM_LI,
		OP_OP_IMM_ADDI,
		OP_OP_IMM,

		OP_OP_ADD,
		OP_OP_SUB,
		OP_OP,

		OP_SYSCALL,
		OP_EBREAK,
		OP_SYSTEM,

		OP_LUI,
		OP_AUIPC,
		OP_FENCE,

		OP_OP_IMM32_ADDIW,
		OP_OP_IMM32,
		OP_OP32_ADDW,
		OP_OP32,
		/* Floating-point */
		OP_FLW_FLD,
		OP_FSW_FSD,
		OP_FMADD,
		OP_FMSUB,
		OP_FNMSUB,
		OP_FNMADD,
		OP_FADD,
		OP_FSUB,
		OP_FMUL,
		OP_FDIV,
		OP_FSGNJ_NX,
		OP_FMIN_FMAX,
		OP_FSQRT,
		OP_FEQ_FLT_FLE,
		OP_FCVT_SD_DS,
		OP_FCVT_W_SD,
		OP_FCVT_SD_W,
		OP_FMV_X_W,
		OP_FMV_W_X,
		/* Atomics */
		OP_LOAD_RESV,
		OP_STORE_COND,
		OP_AMOADD,
		OP_AMOSWAP,
		OP_AMOOR,

		ICACHE_OPS_MAX
	};
	static_assert(ICACHE_OPS_MAX <= DecoderCache::OPS, "Must fit in LUT");

	#define HANDLER_FOR(x) DECODED_INSTR(x).handler
	#define DEF_ICOP(x) [OP_ ##x] = HANDLER_FOR(x)

	template <>
	const instruction_handler<RVIARCH> DecoderCache::lut<RVIARCH> [256] {
		DEF_ICOP(ILLEGAL),
		DEF_ICOP(UNIMPLEMENTED),
		DEF_ICOP(NOP),

		DEF_ICOP(LOAD_I8),
		DEF_ICOP(LOAD_I8_DUMMY),
		DEF_ICOP(LOAD_I16),
		DEF_ICOP(LOAD_I16_DUMMY),
		DEF_ICOP(LOAD_I32),
		DEF_ICOP(LOAD_I32_DUMMY),
		DEF_ICOP(LOAD_U8),
		DEF_ICOP(LOAD_U16),
		DEF_ICOP(LOAD_U32),
		DEF_ICOP(LOAD_U64),
		DEF_ICOP(LOAD_U64_DUMMY),

		DEF_ICOP(STORE_I8),
		DEF_ICOP(STORE_I8_IMM),
		DEF_ICOP(STORE_I16_IMM),
		DEF_ICOP(STORE_I32_IMM),
		DEF_ICOP(STORE_I64_IMM),

		DEF_ICOP(BRANCH_EQ),
		DEF_ICOP(BRANCH_NE),
		DEF_ICOP(BRANCH_LT),
		DEF_ICOP(BRANCH_GE),
		DEF_ICOP(BRANCH_LTU),
		DEF_ICOP(BRANCH_GEU),

		DEF_ICOP(JALR),
		DEF_ICOP(JAL),
		DEF_ICOP(OP_IMM_LI),
		DEF_ICOP(OP_IMM_ADDI),
		DEF_ICOP(OP_IMM),

		DEF_ICOP(OP_ADD),
		DEF_ICOP(OP_SUB),
		DEF_ICOP(OP),

		DEF_ICOP(SYSCALL),
		DEF_ICOP(EBREAK),
		DEF_ICOP(SYSTEM),

		DEF_ICOP(LUI),
		DEF_ICOP(AUIPC),
		DEF_ICOP(FENCE),

		DEF_ICOP(OP_IMM32_ADDIW),
		DEF_ICOP(OP_IMM32),
		DEF_ICOP(OP32_ADDW),
		DEF_ICOP(OP32),

		DEF_ICOP(FLW_FLD),
		DEF_ICOP(FSW_FSD),
		DEF_ICOP(FMADD),
		DEF_ICOP(FMSUB),
		DEF_ICOP(FNMSUB),
		DEF_ICOP(FNMADD),
		DEF_ICOP(FADD),
		DEF_ICOP(FSUB),
		DEF_ICOP(FMUL),
		DEF_ICOP(FDIV),
		DEF_ICOP(FSGNJ_NX),
		DEF_ICOP(FMIN_FMAX),
		DEF_ICOP(FSQRT),
		DEF_ICOP(FEQ_FLT_FLE),
		DEF_ICOP(FCVT_SD_DS),
		DEF_ICOP(FCVT_W_SD),
		DEF_ICOP(FCVT_SD_W),
		DEF_ICOP(FMV_X_W),
		DEF_ICOP(FMV_W_X),

		DEF_ICOP(LOAD_RESV),
		DEF_ICOP(STORE_COND),
		DEF_ICOP(AMOADD),
		DEF_ICOP(AMOSWAP),
		DEF_ICOP(AMOOR),

		/* Remaining OPs */
		HANDLER_FOR(ILLEGAL)
	};

	template <>
	uint8_t DecoderCache::translate<RVIARCH>(instruction_handler<RVIARCH> h) noexcept
	{
		for (size_t i = 0; i < ICACHE_OPS_MAX; i++)
			if (lut<RVIARCH>[i] == h) return i;
		return OP_ILLEGAL;
	}
}
